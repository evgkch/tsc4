{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

(cell) helper_encrypt(int start, int shift, slice text) {
  builder b = begin_cell();
  if (start) {
    b = b.store_uint(0, 32);
  }
  cell tail = null();
  if (~ text.slice_refs_empty?()) {
    tail = helper_encrypt(0, shift, text~load_ref().begin_parse());
  }
  while (~ text.slice_data_empty?()) {
    int x = text~load_uint(7);
    x = (x + shift) % 128;
    b = b.store_uint(x, 7);
  }
  if (~ tail.cell_null?()) {
    b = b.store_ref(tail);
  }
  return b.end_cell();
}

(cell) helper_decrypt(int start, int shift, slice text) {
  builder b = begin_cell();
  if (start) {
    b = b.store_uint(0, 32);
  }
  cell tail = null();
  if (~ text.slice_refs_empty?()) {
    tail = helper_decrypt(0, shift, text~load_ref().begin_parse());
  }
  while (~ text.slice_data_empty?()) {
    int x = text~load_uint(7);
    if (x - shift < 0) {
      x = (x + 128 - shift) % 128;
    }
    else {
      x = (x - shift) % 128;
    }
    b = b.store_uint(x, 7);
  }
  if (~ tail.cell_null?()) {
    b = b.store_ref(tail);
  }
  return b.end_cell();
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  if (shift == 0) {
    return text;
  }
  slice ts = text.begin_parse();
  ts~skip_bits(32);
  cell t = helper_encrypt(-1, shift, ts);
  return t;
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  if (shift == 0) {
    return text;
  }
  slice ts = text.begin_parse();
  ts~skip_bits(32);
  cell t = helper_decrypt(-1, shift, ts);
  return t;
}

